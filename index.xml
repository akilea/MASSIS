<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MASSIS Framework</title>
    <link>http://www.massisframework.com/</link>
    <description>Recent content on MASSIS Framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Nov 2056 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.massisframework.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Designing the simulation environment</title>
      <link>http://www.massisframework.com/post/tutorials/environment-design/</link>
      <pubDate>Sun, 05 Nov 2056 00:00:00 +0000</pubDate>
      
      <guid>http://www.massisframework.com/post/tutorials/environment-design/</guid>
      <description>

&lt;h2 id=&#34;environment-editor:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Environment editor&lt;/h2&gt;

&lt;p&gt;The environment editor of MASSIS is  &lt;a href=&#34;http://www.sweethome3d.com&#34;&gt;SweetHome3D&lt;/a&gt;, which has been extended with plugins, for connecting the editor with the simulation.
More information about extending SweetHome3D via plugins can be found in the &lt;a href=&#34;http://www.sweethome3d.com/pluginDeveloperGuide.jsp&#34;&gt;Plugins&amp;rsquo; developer guide&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;More information:&lt;/strong&gt;
The code for SweetHome3D is also &lt;a href=&#34;https://github.com/rpax/sweethome3d&#34;&gt;available at github&lt;/a&gt;, and configured as maven dependency.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;More information:&lt;/strong&gt;
Note that the editor launched &lt;em&gt;is not exactly&lt;/em&gt; the SweetHome3D editor. The main class of the editor extends &lt;code&gt;SweetHome3D&lt;/code&gt; class, with support for loading plugins at runtime. This can be used for other applications. The source code can be found at&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/rpax/massis-sh3d-plugins/tree/master/sh3d-additionaldata-app&#34;&gt;https://github.com/rpax/massis-sh3d-plugins/tree/master/sh3d-additionaldata-app&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;More information about how to load custom plugins dynamically can be found
&lt;a href=&#34;http://www.massisframework.com/post/loading-custom-plugins-dynamically&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;designing-the-environment:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Designing the environment&lt;/h2&gt;

&lt;h3 id=&#34;creating-editing-walls:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Creating &amp;amp; Editing walls&lt;/h3&gt;

&lt;p&gt;The creation of walls can be done in two ways:
* Selecting Plan → Create walls&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/dkkDSaR.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pressing the &lt;img src=&#34;http://i.imgur.com/i4qzaDX.png&#34; alt=&#34;&#34; /&gt; icon.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After that, every left click in the map will create a wall. For finishing the wall creation mode, just click the arrow icon or press the Esc key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/DAiFfI5.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;adding-doors-windows-furniture:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Adding doors, windows &amp;amp; furniture&lt;/h3&gt;

&lt;p&gt;The furniture, doors and windows can be selected from the left pane, and can be placed into the building by dragging and dropping them. &lt;strong&gt;Note&lt;/strong&gt;: it is important to place the doors and windows in the walls. Otherwise, the simulation may not work correctly.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/bdr0Vvp.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;importing-3d-objects:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Importing 3D objects&lt;/h3&gt;

&lt;p&gt;Extra 3D objects can be imported, and configured as window/door/furniture, from Furniture → Import Furniture.&lt;/p&gt;

&lt;h3 id=&#34;drawing-rooms:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Drawing rooms&lt;/h3&gt;

&lt;p&gt;Rooms can be added the same way as walls, using the  button or selecting the option in Plan → Create Rooms.
&lt;em&gt;&lt;strong&gt;Very important note&lt;/strong&gt;&lt;/em&gt;: This way is highly discouraged for creating environments for MASSIS. As MASSIS uses the rooms in its preprocessing algorithms, a bad placement of them can make the simulation behave incorrectly, or even failing. The preferred way is double clicking a closed area, surrounded by walls. In this way, the new room will occupy the entire space.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/1SjFlDv.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Levels can be added by clicking the + icon in the Levels tab&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/csxX8hB.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;metadata-editor:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Metadata Editor&lt;/h2&gt;

&lt;p&gt;MASSIS needs extra, user-provided information about the elements of the building. This information is stored as metadata inside each element of the building. Every element in the building has metadata, can be viewed and edited directly from Tools → Add Metadata. This popups a simple modal dialog, with input fields in the form of  key – value pairs. These values are read and processed later by MASSIS.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/sq3FNZE.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;teleport-linking:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Teleport Linking&lt;/h2&gt;

&lt;p&gt;In a building of multiple floors, the agents must be capable of moving through the different floors of the building. This is done via &lt;em&gt;Teleports&lt;/em&gt; : Special elements in the building that, as the name suggests, they teleport the agent from one location to another, and they are unidirectional.&lt;/p&gt;

&lt;p&gt;A correctly configured teleport consists on two elements, representing the origin area and the destination area. Any furniture object can be configured as teleport. However, MASSIS release comes with a group of 3D objects designed with this purpose, in order to make easier the design and recognition of them.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/79suUPY.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A Teleport object must have the following parameters,
&lt;code&gt;type&lt;/code&gt; : &lt;code&gt;START&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;
&lt;code&gt;teleport&lt;/code&gt;: the teleport name
So, in the building, there would be two elements with the same teleport attribute, one with &lt;code&gt;START&lt;/code&gt; as value of type, and the other one with &lt;code&gt;END&lt;/code&gt; as value. The meradata of an element conforming the Teleport &lt;code&gt;SB1_B_LEFT&lt;/code&gt; would be like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/jwtsqoT.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;other-massis-design-utilities:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Other MASSIS&amp;rsquo; Design Utilities&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important Note&lt;/strong&gt;: Due to some important changes in the MASSIS&amp;rsquo; framework during November 2015, this feature has been temporarily disabled. Although The code can be found in the &lt;a href=&#34;https://github.com/rpax/MASSIS/tree/master/massis-sh3d-plugins&#34;&gt;main MASSIS repository&lt;/a&gt;, it is not integrated in the application. These plugins will be moved to the &lt;a href=&#34;https://github.com/rpax/massis-sh3d-plugins/&#34;&gt;plugins repository&lt;/a&gt; as soon as possible. The information shown below it is not longer valid.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MASSIS comes with some other design utilities, that can be found at Tools → Designer tools or Name Generation.&lt;/p&gt;

&lt;h3 id=&#34;designer-tools:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Designer tools&lt;/h3&gt;

&lt;p&gt;This plugin can make the external walls invisible(not every wall, so the interior of the building can be viewed from the outside, without making all the walls invisible).
One of the most boring things when designing a building is doing repetitive tasks one by one. For example, the color of the floor. This must be done clicking and modifying each room, in the SweetHome3D&amp;rsquo;s way. With the Rooms Color plugin, this task can be done automatically.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/gDWh2vBm.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;name-generation:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Name Generation&lt;/h3&gt;

&lt;p&gt;This plugin gives a name with the specified prefix to every room, or door in the building.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/rKIMX5W.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;final-notes:503de2820c07a9b745c7e4008aa66e0e&#34;&gt;Final notes&lt;/h2&gt;

&lt;p&gt;This section is not intended to replace SweetHome3D&amp;rsquo;s manual, only as a getting started guide. For more information, refer to the &lt;a href=&#34;http://www.sweethome3d.com/userGuide.jsp&#34;&gt;SweetHome3D manual&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Operation: Rescue the robots. Part 1</title>
      <link>http://www.massisframework.com/post/tutorials/operation-rescue-the-robots/</link>
      <pubDate>Mon, 23 Nov 2015 10:21:39 +0100</pubDate>
      
      <guid>http://www.massisframework.com/post/tutorials/operation-rescue-the-robots/</guid>
      <description>

&lt;p&gt;It is assumed in this tutorial that the reader has already gone through the basic tutorials, such as &lt;a href=&#34;http://www.massisframework.com/page/getting-started/&#34;&gt;the getting started guide&lt;/a&gt; and &lt;a href=&#34;http://www.massisframework.com/post/tutorials/sample-massis-application/&#34;&gt;Creating a MASSIS Application&lt;/a&gt; sections have been already been read.&lt;/p&gt;

&lt;p&gt;For designing the scenario, it is recommended to read the &lt;a href=&#34;http://www.massisframework.com/post/tutorials/environment-design/&#34;&gt;environment design&lt;/a&gt; section.&lt;/p&gt;

&lt;h2 id=&#34;scenario-description:6b32bd56400fe0844b5789f3d73d3322&#34;&gt;Scenario description&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/tRexsTw.png&#34; alt=&#34;Scenario&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The scenario to be simulated is the following:&lt;/p&gt;

&lt;p&gt;he impact of a meteorite has caused irreparable damage to an extraterrestrial station. Luckily, there were no humans on the station, only robots.&lt;/p&gt;

&lt;p&gt;But these robots were controlled remotely, and the meteorite impact has broken one antenna. In order to solve this issue, a new kind of robots are sent to this station. Their mission will consist on rescuing the robots that are in the incommunicated station.&lt;/p&gt;

&lt;p&gt;The scenario used in this tutorial can be downloaded &lt;a href=&#34;https://drive.google.com/open?id=0B3-oRpDTDan3Z3dRQmVXalBYYkU&#34;&gt;from here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;First, we will start modelling the behavior of the robot in the station (the one incommunicated).
In case of lost of communication, these robots behave as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Worker&amp;rdquo; robot behavior

&lt;ol&gt;
&lt;li&gt;Waits until someone tells him what target should be following.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Rescuer&amp;rdquo; robot behavior

&lt;ol&gt;
&lt;li&gt;Tries to visit all the rooms in the building. Whenever this robot sees a worker robot in the room, makes that worker robot to follow him.&lt;/li&gt;
&lt;li&gt;When two (or more) &lt;em&gt;rescuer&lt;/em&gt; robots are in the same room, they share information about the rooms visited.&lt;/li&gt;
&lt;li&gt;When all the rooms have been explored, this robot goes back to the &lt;em&gt;landing zone&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;implementation-from-the-idea-to-the-code:6b32bd56400fe0844b5789f3d73d3322&#34;&gt;Implementation - From the idea to the code&lt;/h2&gt;

&lt;p&gt;This project will be based on the  &lt;a href=&#34;http://www.massisframework.com/post/tutorials/sample-massis-application/&#34;&gt;basic MASSIS archetype explained previously&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;two-behaviors-imply-two-classes:6b32bd56400fe0844b5789f3d73d3322&#34;&gt;Two behaviors imply two classes.&lt;/h3&gt;

&lt;p&gt;Each behavior should be modeled as a Java class. In this scenario, we have two different behaviors, the &lt;em&gt;Worker&lt;/em&gt; behavior and the &lt;em&gt;Rescuer&lt;/em&gt; behavior.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Worker&lt;/em&gt; behavior is fairly simple: Just a translation of the behavior definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.myawesomesimulator.ai;

import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.massisframework.massis.model.agents.HighLevelController;
import com.massisframework.massis.model.agents.LowLevelAgent;
import com.massisframework.massis.model.managers.movement.ApproachCallback;
import com.massisframework.massis.pathfinding.straightedge.FindPathResult.PathFinderErrorReason;

public class WorkerController extends HighLevelController {

  private static final long serialVersionUID = 1L;

  private LowLevelAgent followTarget;

  public WorkerController(LowLevelAgent agent, Map&amp;lt;String, String&amp;gt; metadata,
      String resourcesFolder) {
    super(agent, metadata, resourcesFolder);
    this.agent.setHighLevelData(this);
  }

  @Override
  public void stop() {

  }

  @Override
  public void step() {
    if (this.followTarget != null) {
      this.agent.approachTo(this.followTarget.getLocation(),
        new ApproachCallback() {

          @Override
          public void onTargetReached(LowLevelAgent agent) {
            // Nothing. We are going to follow the target forever.

          }

          @Override
          public void onSucess(LowLevelAgent agent) {
            // Continue following the target.
          }

          @Override
          public void onPathFinderError(PathFinderErrorReason reason) {
            Logger.getLogger(WorkerController.class.getName()).log(
                Level.SEVERE,
                &amp;quot;An error occurred when approaching to {0}. Reason: {1}&amp;quot;,
                new Object[] { followTarget.getLocation(), reason });

          }
        });
    }
  }

  public void setFollowTarget(LowLevelAgent agent) {
    this.followTarget = agent;
  }

  public boolean isFollowingSomeone() {
    return this.followTarget != null;
  }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is! Simple, huh?&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Rescuer&lt;/em&gt; behavior is a little more tricky. Let&amp;rsquo;s split it into parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Tries to visit all the rooms in the building.&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;This imply that the robot should track the rooms that it has visited.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Whenever this robot sees a worker robot in the room, makes that worker robot to follow him.&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;We need some type of gathering information about the current room.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;When two (or more) rescuer robots are in the same room, they share information about the rooms visited.&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;This can be accomplished interchanging the visited rooms of each robot.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;When all the rooms have been explored, this robot goes back to the landing zone&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;This is just a basic operation.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With this facts identified, the only thing left is to code them in a &lt;code&gt;HighLevelController&lt;/code&gt;.
As we have created the project using the archetype, designing the behavior becomes a &lt;em&gt;fill in the gaps&lt;/em&gt; exercise.
The attributes needed should be the unexplored rooms, the next room to visit and (optional, but useful in this case) if the work has finished or not.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Collection&amp;lt;SimRoom&amp;gt; roomsUnexplored;
private SimRoom assignedRoom;
private boolean workFinished;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the constructor we should initialize the unexplored rooms, and setting the &lt;code&gt;workFinished&lt;/code&gt; attribute to false.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public RescuerController(LowLevelAgent agent, Map&amp;lt;String, String&amp;gt; metadata,
        String resourcesFolder) {
    super(agent, metadata, resourcesFolder);
    this.agent.setHighLevelData(this);
    this.workFinished = false;
    this.roomsUnexplored = new HashSet&amp;lt;&amp;gt;();
    for (SimRoom r : this.agent.getLocation().getFloor().getRooms()) {
        this.roomsUnexplored.add(r);
    }
    this.logger = Logger.getLogger(&amp;quot;Rescuer_&amp;quot; + agent.getID());
    this.assignNewRoomToExplore();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This robot should interchange the information about the rooms with other robots:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void shareRoomsWith(RescuerController rescuer) {
    // remove every item that is not present in the other map
    final boolean changed = this.roomsUnexplored
            .retainAll(rescuer.roomsUnexplored);
    if (changed) {
        logger.log(Level.INFO,
                &amp;quot;Updated information about rooms to explore: {0}&amp;quot;,
                this.roomsUnexplored);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This robot should be capable of auto-assigning rooms to explore:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void assignNewRoomToExplore() {
    if (!this.roomsUnexplored.isEmpty()) {
        SimRoom[] rem = this.roomsUnexplored.toArray(new SimRoom[] {});
        this.assignedRoom = rem[ThreadLocalRandom.current()
                .nextInt(rem.length)];
        this.roomsUnexplored.remove(this.assignedRoom);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, for approaching to its current target, this method can be written for clarity:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void approachToAssignedRoom() {
  this.agent.approachTo(this.assignedRoom.getLocation(),
    new ApproachCallback() {

        @Override
        public void onTargetReached(LowLevelAgent agent) {
            assignNewRoomToExplore();
        }

        @Override
        public void onSucess(LowLevelAgent agent) {
        }

        @Override
        public void onPathFinderError(
                PathFinderErrorReason reason) {
            logger.log(Level.SEVERE,
                    &amp;quot;An error occurred when approaching to room {0} Reason: {1}&amp;quot;,
                    new Object[] { reason, assignedRoom.getID() });

        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, for approaching to the &lt;em&gt;landing zone&lt;/em&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void approachToLandingZone() {
    if (!this.workFinished) {
        this.agent.approachToNamedLocation(&amp;quot;LANDING_ZONE&amp;quot;,
            new ApproachCallback() {
                @Override
                public void onTargetReached(LowLevelAgent agent) {
                    // Work finished.
                    RescuerController.this.workFinished = true;
                }
                @Override
                public void onSucess(LowLevelAgent agent) {
                }
                @Override
                public void onPathFinderError(
                        PathFinderErrorReason reason) {
                    logger.log(Level.SEVERE,
                            &amp;quot;An error occurred when approaching &amp;quot;
                                    + &amp;quot;to landing zone. Reason: {0}&amp;quot;,
                            reason);

                }
            });
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This utility methods are intended for using them in the &lt;code&gt;step()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void step() {
    /*
     * Is anybody in the room?
     */
    if (!this.roomsUnexplored.isEmpty()) {
        /*
         * For each agent found in the room, do the corresponding task
         */
        for (LowLevelAgent otherAgent : this.agent.getAgentsInRoom()) {
            // avoid self
            if (this.agent == otherAgent)
                continue;
            /*
             * Is a rescuer?
             */
            if (otherAgent
                    .getHighLevelData() instanceof RescuerController) {
                /*
                 * Affirmative. Share room information
                 */
                shareRoomsWith(
                        (RescuerController) otherAgent.getHighLevelData());
                /*
                 * Is a worker? follow me.
                 */
            } else if (otherAgent
                    .getHighLevelData() instanceof WorkerController) {

                final WorkerController follower = (WorkerController) otherAgent
                        .getHighLevelData();
                /*
                 * Check if the robot is already following someone
                 */
                if (!follower.isFollowingSomeone()) {
                    follower.setFollowTarget(this.agent);
                }
            }

        }
        this.approachToAssignedRoom();

    } else {
        // Go to landing zone.
        this.approachToLandingZone();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s everything! If you prefer to download the entire project, with the building included, &lt;a href=&#34;https://drive.google.com/open?id=0B3-oRpDTDan3Nl9pdUdDRUY0cDQ&#34;&gt;you can do it from here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating a MASSIS Application. Part 2: Customizing the archetype</title>
      <link>http://www.massisframework.com/post/tutorials/customizing-the-archetype/</link>
      <pubDate>Fri, 06 Nov 2015 13:19:52 +0100</pubDate>
      
      <guid>http://www.massisframework.com/post/tutorials/customizing-the-archetype/</guid>
      <description>

&lt;p&gt;This is the continuation of the &lt;a href=&#34;http://www.massisframework.com/post/tutorials/sample-massis-application/&#34;&gt;First tutorial&lt;/a&gt;, which explains how to create a MASSIS project based on an archetype.&lt;/p&gt;

&lt;h2 id=&#34;remembering-things-what-is-in-the-project:ef4bf10577d09165b17453e8a9e1b79e&#34;&gt;Remembering things: What is in the project?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EnvironmentEditor.java&lt;/code&gt; : Contains the necessary code for launching the environment editor.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SimulationWithUILauncher.java&lt;/code&gt; : This class is responsible for launching the simulator&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyHelloHighLevelController&lt;/code&gt; : A behavior definion sample.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;configuring-the-environment:ef4bf10577d09165b17453e8a9e1b79e&#34;&gt;Configuring the environment.&lt;/h2&gt;

&lt;p&gt;MASSIS simulator uses sweethome3d as environment definition. The behavior of the elements should be specified in the building file, and implemented as a class.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/z3aw4bl.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;opening-the-editor-and-loading-a-default-building:ef4bf10577d09165b17453e8a9e1b79e&#34;&gt;Opening the editor and loading a default building&lt;/h3&gt;

&lt;p&gt;Running the &lt;code&gt;EnvironmentEditor&lt;/code&gt; class (Run As&amp;hellip;-&amp;gt; Java Application) should open SweetHome3D&amp;rsquo;s editor with some of the MASSIS&amp;rsquo; plugins.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/pW8lgjG.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3D [dev] 1.6.0-scijava-1-pre11-daily-experimental daily

loading class com.massisframework.sweethome3d.plugins.BuildingMetadataPlugin
loading class com.massisframework.testdata.TestDataPlugin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the main window of the SweetHome3D editor. During the tutorials, some of the most important features of MASSIS and Sweethome3D editor will be explained. For loading a sample building, click on &lt;em&gt;Help -&amp;gt; Load Sample Home&amp;hellip;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/l9umHvv.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the popup, select &amp;ldquo;basichouse.sh3d&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/7AnSp7i.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A new home will be opened. This basic home contains a basic agent, four walls and a room.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/mqORvHr.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;referencing-the-behavior-of-the-agent:ef4bf10577d09165b17453e8a9e1b79e&#34;&gt;Referencing the behavior of the agent.&lt;/h3&gt;

&lt;p&gt;Every element in the SweetHome3D editor (with massis plugins) has metadata attached.
For modifing the metadata of an element, the element &lt;strong&gt;should be selected first&lt;/strong&gt; and clicking on &lt;em&gt;Tools -&amp;gt; Add Metadata&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/mQZIAAp.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see what kind of metadata attached has the agent in the room.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/UF4NV2m.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IS_OBSTACLE&lt;/code&gt; : Tells if this element is an obstacle or not. &lt;strong&gt;This topic will be covered later&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ID&lt;/code&gt; : The unique id of the element in the building. &lt;strong&gt;It is not recomended to change the value&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IS_DYNAMIC&lt;/code&gt; : If the element is going to move during the simulation. Acts as a hint for the pathfinder and the visualization toolkit. &lt;strong&gt;This topic will be covered later&lt;/strong&gt;.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;CLASSNAME&lt;/code&gt; : The reference to the class implementing the agent behavior. By default, its value is &lt;code&gt;com.massisframework.testdata.ai.HelloHighLevelController&lt;/code&gt;. We want to change this to our custom implementation. So, the value, in this case should be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tutorialfollower.myfirstmassisproject.MyHelloHighLevelController
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;saving-the-sample-home-in-another-location:ef4bf10577d09165b17453e8a9e1b79e&#34;&gt;Saving the sample home in another location.&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Maybe you have noticed that the name of the home is kind of strange. Something like _MASSIS&lt;em&gt;278234761.sh3d&lt;/em&gt;. This name is like this because the location of this home is &lt;strong&gt;temporary&lt;/strong&gt;. In order to preserve the changes, must be saved in a &lt;strong&gt;non temporary&lt;/strong&gt; location.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s save the home in the project root folder for making easier the access from the simulator, in this tutorial.
Cliking &lt;em&gt;Save As&amp;hellip;&lt;/em&gt; -&amp;gt; Tutorial1.sh3d on the project&amp;rsquo;s root folder.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/775jxVI.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: remember to refresh the eclipse project, in order to see if the file it is actually there.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;running-the-simulation:ef4bf10577d09165b17453e8a9e1b79e&#34;&gt;Running the simulation&lt;/h2&gt;

&lt;p&gt;Once saved, let&amp;rsquo;s run our first simulation. First, we need to change the path of the building file.
In &lt;code&gt;SimulationWithUILauncher&lt;/code&gt;, change&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buildingFilePath = SampleHomesLoader.loadHomeTempFile(&amp;quot;basichouse&amp;quot;).getAbsolutePath();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buildingFilePath = &amp;quot;Tutorial1.sh3d&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And remove the try-catch, it is not necessary anymore.&lt;/p&gt;

&lt;p&gt;It should appear the MASSIS default gui,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/kPN5EI7.png&#34; alt=&#34;&#34; /&gt;,&lt;/p&gt;

&lt;p&gt;and some console logs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;current-max-id: 17
Creating level NONAME
======================================================
Creating floor from level [NONAME]
Initializing simulation objects..
# of SimulationObjects: 1
# of rooms: 1
======================================================
Before/After Reduction : 4/2,[22=&amp;gt;16] took 6 ms

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s next? &lt;a href=&#34;http://www.massisframework.com/post/tutorials/defining-a-simple-behavior/&#34;&gt;Creating a MASSIS Application. Part 3: Defining a simple behavior&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating a MASSIS Application. Part 3: Defining a simple behavior</title>
      <link>http://www.massisframework.com/post/tutorials/defining-a-simple-behavior/</link>
      <pubDate>Fri, 06 Nov 2015 13:19:52 +0100</pubDate>
      
      <guid>http://www.massisframework.com/post/tutorials/defining-a-simple-behavior/</guid>
      <description>

&lt;p&gt;This is the continuation of the &lt;a href=&#34;http://www.massisframework.com/post/tutorials/customizing-the-archetype/&#34;&gt;Second tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the previous tutorial, we learnt how to change properties of the elements of the environment and launching the simulation. In this tutorial, we will learn the basics of the simulation gui, and a simple example about how to manage the behavior of the agent in the environment.&lt;/p&gt;

&lt;h1 id=&#34;the-simulation-gui:eefcc561692713ed4045ec5201f4fd82&#34;&gt;The simulation GUI.&lt;/h1&gt;

&lt;p&gt;In the previous tutorial, we executed &lt;code&gt;SimulationWithUILauncher&lt;/code&gt;, and the following window appeared.Let&amp;rsquo;s explain briefly the contents of this window.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;About : Shows some a welcome screen, and copyright imformation. The three buttons on the bottom-left side control the most basic functionalities of the simulator:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Advance one step&lt;/li&gt;
&lt;li&gt;Run continuously&lt;/li&gt;
&lt;li&gt;Stop
&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/kPN5EI7.png&#34;/&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Console : Controls simulation parameters.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Delay (Sec/Step) : Delay between steps in the simulation&lt;/li&gt;
&lt;li&gt;Steps per Step-button : Number of steps to be executed every time the play-pause button is pressed.
&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/SI7dSrf.png&#34;/&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Displays: This tab offers different ways for visualizing the state of the simulation. They can be shown or hidden anytime, with the simulation running also.  &lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/PptfTUD.png&#34;/&gt;&lt;/figure&gt;
  There are three different types of visualization:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Building map : Shows the 2D layer- based map. This is the most powerful, flexible and customizable visualization tool of MASSIS. This type of display is deeply explained in  &lt;a href=&#39;#&#39; class=&#34;top-tip&#34; data-tips=&#39;Not written yet :(&#39;&gt;this tutorial&lt;/a&gt;
. &lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/IcRLXtI.png&#34;/&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;Building 2D :  Shows SweetHome3D default 2D viewer. It is included because maybe it is useful in the future. Although it is not recommended: Is not optimized for the simulation, and has thread-safety issues.&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/2tnx3mF.png&#34;/&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;Building 3D: Shows the 3D viewer. The camera can be controlled with the mouse or keyboard&lt;/li&gt;
&lt;li&gt;Keyboard:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt; moves the camera backwards&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; moves the camera forward.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Caps lock&lt;/code&gt; (&amp;#8682;) makes the movement of the camera faster.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Mouse:

&lt;ul&gt;
&lt;li&gt;The mouse wheel moves the camera backwards/forward&lt;/li&gt;
&lt;li&gt;The mouse movement changes the view direction&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;first-run:eefcc561692713ed4045ec5201f4fd82&#34;&gt;First Run&lt;/h1&gt;

&lt;p&gt;Ok, so let&amp;rsquo;s press the &lt;em&gt;Play&lt;/em&gt; (&lt;img src=&#34;http://i.imgur.com/D6C9dta.png?1&#34; alt=&#34;&#34; /&gt;) button. What happens?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The &lt;em&gt;step counter&lt;/em&gt; increases its value very fast&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The output of the console is always the same:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hey! I am an agent!
Hey! I am an agent!
Hey! I am an agent!
Hey! I am an agent!
Hey! I am an agent!
Hey! I am an agent!
Hey! I am an agent!
Hey! I am an agent!
Hey! I am an agent!
Hey! I am an agent!
Hey! I am an agent!
... etc
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Nothing moves.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Why? because the behavior of the agent, defined by its &lt;em&gt;High Level Controller&lt;/em&gt; is exactly that.&lt;/p&gt;

&lt;h1 id=&#34;what-is-a-highlevelcontroller:eefcc561692713ed4045ec5201f4fd82&#34;&gt;What is a &lt;em&gt;HighLevelController&lt;/em&gt; ?&lt;/h1&gt;

&lt;p&gt;In MASSIS, the &lt;em&gt;High Level Controllers&lt;/em&gt; manage the agent&amp;rsquo;s behavior. In our case, the &lt;code&gt;MyHelloHighLevelController.java&lt;/code&gt; file contains the following code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class MyHelloHighLevelController extends HighLevelController {

    public MyHelloHighLevelController(
        /*1*/ LowLevelAgent agent,
        /*2*/ Map&amp;lt;String, String&amp;gt; metadata,
        /*3*/ String resourcesFolder) {

        super(agent, metadata, resourcesFolder);
        this.agent.setHighLevelData(this);
    }

    @Override
    public void stop() {
        /*4*/
        /*  Clean resources, threads...etc */
    }

    @Override
    public void step() {
        /*5*/
        System.out.println(&amp;quot;Hey! I am an agent!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s explain it by parts (marked in the code between &lt;code&gt;/**/&lt;/code&gt;)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;What is a &lt;em&gt;LowLevelAgent&lt;/em&gt; ?&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;LowLevelAgent&lt;/em&gt; is the element that provides the &lt;em&gt;HighLevelController&lt;/em&gt; the necessary information for taking decisions. Also, the HighLevelController changes the state of the LowLevelAgent. (Making it move, changing its properties, other agent&amp;rsquo;s properties, interaction, etc.).&lt;/p&gt;

&lt;p&gt;The following diagram may help to understand how MASSIS is structured:
&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/SBuHKz7.png&#34;/&gt;&lt;/figure&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the &lt;em&gt;metadata&lt;/em&gt; parameter?&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;metadata&lt;/code&gt; map is the map containing all the key-value entries that are introduced in the agent through the environment editor. Depending on the complexity of the behavior, the agent may need additional parameters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;hellip;And the resources folder?&lt;/p&gt;

&lt;p&gt;The agent may need external resources (like a plan definition), or maybe the function of that agent is to write something. The &lt;code&gt;resourcesfolder&lt;/code&gt; parameter is the folder in where the I/O of the agent should be done.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the &lt;code&gt;stop()&lt;/code&gt; method for?&lt;/p&gt;

&lt;p&gt;Before the simulation finishes (or the agent is shut down), the &lt;code&gt;stop()&lt;/code&gt; method is called. Can be seen as the last call to the &lt;code&gt;step()&lt;/code&gt; method.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;And the &lt;code&gt;step()&lt;/code&gt; method?&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;step()&lt;/code&gt; method is where the agent&amp;rsquo;s logic occurs. Every simulation step provokes a call to the agent&amp;rsquo;s step method. Changing the content of this method changes the behavior of the agent.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;bringing-the-agent-the-ability-to-move-randomly:eefcc561692713ed4045ec5201f4fd82&#34;&gt;Bringing the agent the ability to move (randomly)&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s make our agent move. For accomplishing that, the highlevel controller needs the knowledge of the environment that is provided by the LowLevelAgent (such as the room where the agent is), and needs to &lt;em&gt;command&lt;/em&gt; things to it&amp;rsquo;s low-level representation. The &lt;em&gt;LowLevelAgent&lt;/em&gt; interface provides the necessary methods for accomplishing that. Remember that the code is &lt;a href=&#34;https://github.com/rpax/MASSIS&#34;&gt;hosted on github&lt;/a&gt;, so you can check what are &lt;a href=&#34;https://github.com/rpax/MASSIS/blob/master/massisframework/massis/massis-core/src/main/java/com/massisframework/massis/model/agents/LowLevelAgent.java&#34;&gt;the methods offered by a LowLevelAgent&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;What we are going to do is the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Obtain in which room is the agent.
Rooms are represented by the  &lt;a href=&#34;https://github.com/rpax/MASSIS/blob/master/massisframework/massis/massis-core/src/main/java/com/massisframework/massis/model/building/SimRoom.java&#34;&gt;&lt;code&gt;SimRoom&lt;/code&gt;&lt;/a&gt; class. Obtaining the room of the agent can be done by calling the &lt;code&gt;getRoom()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*1*/ SimRoom currentRoom=this.agent.getRoom();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Select a random location in that room. Locations in the environment are represented by the &lt;a href=&#34;https://github.com/rpax/MASSIS/blob/master/massisframework/massis/massis-core/src/main/java/com/massisframework/massis/model/location/Location.java&#34;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*2*/ Location randomLocation = currentRoom.getRandomLoc();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Make the agent move to that point.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The agent needs a target to follow. We will model that as an attribute of the High-Level controller.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*3*/ private Location currentTarget;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The easiest way for approaching to one location is calling to the method &lt;code&gt;approachTo&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* Tries to approach to an specific {@link Location} in the building.
* &amp;lt;p&amp;gt;This method &amp;lt;b&amp;gt;does not&amp;lt;/b&amp;gt; &amp;quot;Move&amp;quot; the agent to one location to
* another instantly. Instead, the agent tries to be closer to the location
* given, avoiding obstacles.&amp;lt;/p&amp;gt;
* &amp;lt;p&amp;gt;
* For moving the agent to one location &amp;lt;i&amp;gt;instantly&amp;lt;/i&amp;gt; the method
* {@link #moveTo(rpax.massis.model.location.Location)} should be used
* instead
*
* @param location the target {@link Location}
* @return if the agent has reached the location or not
*/
public void approachTo(Location location,ApproachCallback callback);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This method requires an &lt;code&gt;ApproachCallback&lt;/code&gt;. The &lt;code&gt;ÀpproachCallback&lt;/code&gt; methods will be called when the pathfinding process has been finished in the current step. In our case,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ApproachCallback callback = new ApproachCallback() {


    @Override
    public void onTargetReached(LowLevelAgent agent) {
        // Target has been reached.
    }


    @Override
    public void onSucess(LowLevelAgent agent) {
        // Ok, there was no problem. The agent has moved a little bit.
    }


    @Override
    public void onPathFinderError(PathFinderErrorReason reason) {
        //Error!
        Logger.getLogger(MyHelloHighLevelController.class.getName())
        .log(Level.SEVERE,
        &amp;quot;Error when approaching to {0} Reason: {1}&amp;quot;,
        new Object[] { currentTarget, reason });
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Putting all together in the &lt;code&gt;step()&lt;/code&gt; method,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void step() {


    if (this.currentTarget == null) {
        /* 1 */ SimRoom currentRoom = this.agent.getRoom();
        /* 2 */ Location randomLocation = currentRoom.getRandomLoc();
        this.currentTarget = randomLocation;
    }
    ApproachCallback callback = new ApproachCallback() {


    @Override
        public void onTargetReached(LowLevelAgent agent) {
        // Target has been reached.
        }


        @Override
        public void onSucess(LowLevelAgent agent) {
            // Ok, there was no problem.
            //The agent has moved a little bit.
        }


        @Override
        public void onPathFinderError(PathFinderErrorReason reason) {
            // Error!
            Logger.getLogger(MyHelloHighLevelController.class.getName())
            .log(Level.SEVERE,
            &amp;quot;Error when approaching to {0} Reason: {1}&amp;quot;,
            new Object[] { currentTarget, reason });
        }
    };


    this.agent.approachTo(this.currentTarget, callback);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can try launching the simulation again. The agent is moving! But it only has a target, and when that target is reached, it starts going forward and backwards, trying again and again to reach the target. We can do a little better.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/hHYGFYY.gif&#34;/&gt;&lt;/figure&gt;


&lt;h1 id=&#34;moving-randomly-to-different-locations:eefcc561692713ed4045ec5201f4fd82&#34;&gt;Moving randomly to different locations&lt;/h1&gt;

&lt;p&gt;In the previous code, the &lt;code&gt;onTargetReached()&lt;/code&gt; method was empty. This method is called when the agent is on the target location. For creating new targets every time the agent reaches one, we can do reset &lt;code&gt;currentTarget&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt; every time the agent reaches the &lt;code&gt;currentTarget&lt;/code&gt; location.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ApproachCallback callback = new ApproachCallback() {

        @Override
        public void onTargetReached(LowLevelAgent agent) {
            currentTarget = null;
        }

        @Override
        public void onSucess(LowLevelAgent agent) {
            // Ok, there was no problem. The agent has moved a little bit.
        }

        @Override
        public void onPathFinderError(PathFinderErrorReason reason) {
            // Error!
            Logger.getLogger(MyHelloHighLevelController.class.getName())
                    .log(Level.SEVERE,
                            &amp;quot;Error when approaching to {0} Reason: {1}&amp;quot;,
                            new Object[] { currentTarget, reason });

        }
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/KgzcWmv.gif&#34;/&gt;&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a lot of things to improve! Take a look at the [Next tutorial][tutorial_4]&lt;/p&gt;

&lt;p&gt;[tutorial_4]: /post/tutorials/bigger-environment-and-multiple-agents/&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating a MASSIS Application. Part 4: Bigger environment and multiple agents</title>
      <link>http://www.massisframework.com/post/tutorials/bigger-environment-and-multiple-agents/</link>
      <pubDate>Fri, 06 Nov 2015 13:19:52 +0100</pubDate>
      
      <guid>http://www.massisframework.com/post/tutorials/bigger-environment-and-multiple-agents/</guid>
      <description>

&lt;p&gt;This is the continuation of the &lt;a href=&#34;http://www.massisframework.com/post/tutorials/defining-a-simple-behavior/&#34;&gt;Third tutorial&lt;/a&gt;. In this tutorial, we will improve the environment and we will add more agents to the simulation.&lt;/p&gt;

&lt;h1 id=&#34;editing-the-environment:16f756c730c6f04258547ab4f61a9781&#34;&gt;Editing the environment&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s add more elements to the environment. For that, we need to launch the editor (&lt;code&gt;EnvironmentEditor.java&lt;/code&gt;).
Sweethome3D saves the recent buildings edited, so clicking on &lt;em&gt;File -&amp;gt; Open Recent -&amp;gt; Tutorial1.sh3d&lt;/em&gt; will open the our simulation environment.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/5JPhrUn.gif&#34;/&gt;&lt;/figure&gt;


&lt;h2 id=&#34;adding-walls-rooms:16f756c730c6f04258547ab4f61a9781&#34;&gt;Adding walls &amp;amp; rooms&lt;/h2&gt;

&lt;p&gt;Walls can be added clicking on &lt;em&gt;Plan -&amp;gt; Create Walls&lt;/em&gt;, with the shortcut &lt;code&gt;Ctrl + Shift + W&lt;/code&gt; or pressing the &lt;img src=&#34;http://i.imgur.com/bc5HLBQ.png&#34; alt=&#34;&#34; /&gt; button.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/42HAACQ.gif&#34;/&gt;&lt;/figure&gt;


&lt;p&gt;The editor supports panning and zooming. Zooming can be done pressing &lt;code&gt;Ctrl&lt;/code&gt; while moving the mouse wheel. Also, it helps with connecting one wall with another. When the mouse is near the wall corners, a bigger point is shown, in order to make easier this task.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/ig7DusU.gif&#34;/&gt;&lt;/figure&gt;


&lt;p&gt;Adding rooms to the scene can be accomplished clicking in &lt;em&gt;Plan-&amp;gt; Create Rooms&lt;/em&gt;, or in the shorcut button
&lt;img src=&#34;http://i.imgur.com/vOnfWjk.png&#34; alt=&#34;&#34; /&gt;. Can be added &lt;em&gt;point-per-point&lt;/em&gt;, but the recommended way is making double click in an area enclosed by walls. It is &lt;strong&gt;very recommended&lt;/strong&gt; to do it that way, because makes easier the environment recognition by the simulator.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/busq3sch.gif&#34;/&gt;&lt;/figure&gt;


&lt;h2 id=&#34;adding-doors:16f756c730c6f04258547ab4f61a9781&#34;&gt;Adding doors&lt;/h2&gt;

&lt;p&gt;Doors play an important role in the simulation. Besides allowing agents to move through them, they made a logical separation between spaces that enhance the performance of the simulation.&lt;/p&gt;

&lt;p&gt;Doors are under the section &lt;em&gt;Doors and Windows&lt;/em&gt;. It is important to snap the doors to the walls, otherwise the simulation pathfinder might fail.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/dzvD847.gif&#34;/&gt;&lt;/figure&gt;


&lt;h2 id=&#34;adding-more-agents:16f756c730c6f04258547ab4f61a9781&#34;&gt;Adding more agents&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s are more agents to the environment. We need to &lt;strong&gt;copy and paste&lt;/strong&gt; the original agent that we have modified in the previous tutorial. Otherwise, the metadata values will be the default ones, and the behavior class will be the default one.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/vriBsoA.gif&#34;/&gt;&lt;/figure&gt;


&lt;h2 id=&#34;running-the-simulation-again:16f756c730c6f04258547ab4f61a9781&#34;&gt;Running the simulation again&lt;/h2&gt;

&lt;p&gt;If we run the simulation again, the agents will start moving randomly. But, they are not using the doors!. That&amp;rsquo;s because in the behavior, we have limited the movement &lt;em&gt;in the current room&lt;/em&gt;, not in the whole environment.&lt;/p&gt;

&lt;p&gt;Changing a little bit the behavior will allow agents to move through doors:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void step() {

    if (this.currentTarget == null) {
    /* 1 */

        Random rnd = ThreadLocalRandom.current();
        Location agentLocation = agent.getLocation();
        Floor agentFloor = agentLocation.getFloor();
        List&amp;lt;SimRoom&amp;gt; roomsInFloor = agentFloor.getRooms();
        int numberOfRooms = roomsInFloor.size();
        int rndRoomIndex = rnd.nextInt(numberOfRooms);
        final SimRoom rndRoom = roomsInFloor.get(rndRoomIndex);

        /* 2 */ Location randomLocation = rndRoom.getRandomLoc();
        this.currentTarget = randomLocation;
    }
//...etc
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;¿What are we doing here?&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;First, we get the agent&amp;rsquo;s location.&lt;/li&gt;
&lt;li&gt;Then, we access the &lt;strong&gt;Floor&lt;/strong&gt; of that location. (What a floor is will be explained in the next section)&lt;/li&gt;
&lt;li&gt;We pick a random room of the current floor.&lt;/li&gt;
&lt;li&gt;And finally, a random point in that room.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/w5GfLJT.gif&#34;/&gt;&lt;/figure&gt;


&lt;h2 id=&#34;what-is-a-floor:16f756c730c6f04258547ab4f61a9781&#34;&gt;What is a Floor?&lt;/h2&gt;

&lt;p&gt;The building model inside the MASSIS simulator is the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A building is composed by different floors, at different heights each one.&lt;/li&gt;
&lt;li&gt;Each floor is divided into &lt;em&gt;rooms&lt;/em&gt;, which are separated by &lt;em&gt;walls&lt;/em&gt; and connected by &lt;em&gt;doors&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Teleports&lt;/em&gt; can connect everything in the building. But that &lt;a href=&#39;#&#39; class=&#34;top-tip&#34; data-tips=&#39;Not written yet :(&#39;&gt;is another tutorial&lt;/a&gt;
.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/HRzd8cD.png&#34;/&gt;&lt;/figure&gt;


&lt;h2 id=&#34;creating-obstacles:16f756c730c6f04258547ab4f61a9781&#34;&gt;Creating obstacles&lt;/h2&gt;

&lt;p&gt;At this moment, the environment has no obstacles. Let&amp;rsquo;s add a some. In the environment editor, go to &lt;em&gt;Miscillaneous -&amp;gt; Box&lt;/em&gt;, and drag it to the scene.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/oIAeeED.gif&#34;/&gt;&lt;/figure&gt;


&lt;p&gt;Save the building and run the simulation again.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/SCqpt8D.gif&#34;/&gt;&lt;/figure&gt;


&lt;p&gt;What happens? The elements added are recognized by the simulator as &lt;strong&gt;static&lt;/strong&gt; obstacles by default, like walls. (Walls are &lt;em&gt;always&lt;/em&gt; an obstacle).&lt;/p&gt;

&lt;p&gt;In this context, the elements can be playing different roles, depending on their metadata. The two tables below explain this keys more formally.&lt;/p&gt;

&lt;hr /&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;IS_OBSTACLE&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Meaning&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Tells if the element represents an obstacle in the environment.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Default&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Allowed values&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;true,false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Keys required&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;IS_DYNAMIC&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Meaning&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Tells if the element has the ability to move. Depending on this value, will be treated as an static obstacle or not&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Default&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Allowed values&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;true,false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Keys required&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;IS_OBSTACLE&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Let&amp;rsquo;s add the entry &lt;code&gt;IS_OBSTACLE = false&lt;/code&gt; in the boxes&amp;rsquo; metadata, and see what happens.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/mvnnlmv.gif&#34;/&gt;&lt;/figure&gt;


&lt;p&gt;The agents now don&amp;rsquo;t try to avoid the boxes, because they are marked as &lt;em&gt;not an obstacle&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/OjLZ6QT.gif&#34;/&gt;&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;And, what if we set a box with the entry &lt;code&gt;IS_DYNAMIC = true&lt;/code&gt; ?&lt;/p&gt;

&lt;p&gt;&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/1nLgQ66.gif&#34;/&gt;&lt;/figure&gt;

The visualization treats the element in a different way, because it is marked as dynamic. Also, the pathfinder does not include this element in the pathfinding process, and the responsability for not &lt;em&gt;bumbing into things&lt;/em&gt; is taken by other method, with &lt;a href=&#34;http://www.red3d.com/cwr/steer/&#34;&gt;steering behaviors&lt;/a&gt;, that are explained in  &lt;a href=&#39;#&#39; class=&#34;top-tip&#34; data-tips=&#39;Not written yet :(&#39;&gt;another tutorial&lt;/a&gt;
.&lt;/p&gt;

&lt;h1 id=&#34;what-to-do-next:16f756c730c6f04258547ab4f61a9781&#34;&gt;What to do next?&lt;/h1&gt;

&lt;p&gt;Our agents can move from/to different locations in the environment, but, what about their &lt;em&gt;perception&lt;/em&gt;? This is explained in the [Next tutorial][tutorial_5].&lt;/p&gt;

&lt;p&gt;[tutorial_5]: /post/tutorials/perception/&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating a MASSIS Application. Part 5: Perception</title>
      <link>http://www.massisframework.com/post/tutorials/perception/</link>
      <pubDate>Fri, 06 Nov 2015 13:19:52 +0100</pubDate>
      
      <guid>http://www.massisframework.com/post/tutorials/perception/</guid>
      <description>

&lt;p&gt;This is the continuation of the &lt;a href=&#34;http://www.massisframework.com/post/tutorials/bigger-environment-and-multiple-agents/&#34;&gt;fourth tutorial&lt;/a&gt;. In this tutorial, we will learn how agents can query some of the properties of the environment, and we will make them to play the tag game.&lt;/p&gt;

&lt;h1 id=&#34;how-agents-can-perceive-the-environment:d7c5f655ae342b94fbf082b33a7e6e52&#34;&gt;How agents can perceive the environment.&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;LowLevelAgent&lt;/code&gt; can obtain information about its environment, such as the room where it is, its current location, and other agents near him.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a simple print method for checking this out. The method &lt;a href=&#34;https://github.com/rpax/MASSIS/blob/master/massisframework/massis/massis-core/src/main/java/com/massisframework/massis/model/agents/LowLevelAgent.java#L52&#34;&gt;&lt;code&gt;getAgentsInRange&lt;/code&gt;&lt;/a&gt; returns the LowLevelAgents within a range of the agent on which the method was performed.&lt;/p&gt;

&lt;p&gt;So, in &lt;code&gt;MyHelloHighLevelControllerjava&lt;/code&gt; we can write the following method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void printAgentsIDsInRange(double range) {
    StringBuilder sb = new StringBuilder();

    for (LowLevelAgent otherAgent : this.agent.getAgentsInRange(range)) {
        final int otherId = otherAgent.getID();
        final Location agentLoc = this.agent.getLocation();
        final Location otherLoc = otherAgent.getLocation();
        final double distance = agentLoc.distance2D(otherLoc);

        sb.append(&amp;quot;\tAgent #&amp;quot;).append(otherId).append(&amp;quot;. distance: &amp;quot;)
                .append(distance).append(&amp;quot;\n&amp;quot;);
    }
    if (sb.length() &amp;gt; 0) {
        System.out.println(&amp;quot;Agent #&amp;quot; + this.agent.getID()+&amp;quot; has in the range of &amp;quot;+range+&amp;quot; cm:&amp;quot;);
        System.out.println(sb.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and add it at the beginning of the &lt;code&gt;step()&lt;/code&gt; method&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void step() {

    printAgentsIDsInRange(200);
    if (this.currentTarget == null) {
        /* 1 */
//etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should print in the console output something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Agent #12 has in the range of 200.0 cm:
    Agent #42. distance: 233.04966693463686

Agent #12 has in the range of 200.0 cm:
    Agent #42. distance: 213.96123582412258

...etc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, agent&amp;rsquo;s can move, and see each other. Let&amp;rsquo;s make them to play a game.&lt;/p&gt;

&lt;h1 id=&#34;the-game:d7c5f655ae342b94fbf082b33a7e6e52&#34;&gt;The Game&lt;/h1&gt;

&lt;h2 id=&#34;game-rules:d7c5f655ae342b94fbf082b33a7e6e52&#34;&gt;Game Rules&lt;/h2&gt;

&lt;p&gt;[Tag Game rules from Wikipedia][tag_game]:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A group of players (two or more) decide who is going to be &amp;ldquo;it&amp;rdquo;, often using a counting-out game such as eeny, meeny, miny, moe.&lt;/p&gt;

&lt;p&gt;The player selected to be &amp;ldquo;it&amp;rdquo; then chases the others, attempting to get close enough to &amp;ldquo;tag&amp;rdquo; one of them (touching them with a hand) while the others try to escape.&lt;/p&gt;

&lt;p&gt;A tag makes the tagged player &amp;ldquo;it&amp;rdquo; - in some variations[&amp;hellip;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;implementation:d7c5f655ae342b94fbf082b33a7e6e52&#34;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;We can model the behavior of the agents following the flowchart below:&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/UNrajuM.png&#34;/&gt;&lt;/figure&gt;


&lt;h3 id=&#34;conditionals:d7c5f655ae342b94fbf082b33a7e6e52&#34;&gt;Conditionals&lt;/h3&gt;

&lt;p&gt;For modeling the conditionals of the flowchart, we need to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Check if the agent is tagged. This can be done in two ways.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Adding a new property to &lt;code&gt;MyHelloHighLevelController&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean tagged;


public boolean isTagged() {
    return tagged;
}


public void setTagged(boolean tagged) {
    this.tagged = tagged;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Using the LowLevelAgent&amp;rsquo;s &lt;code&gt;getProperty()&lt;/code&gt; and &lt;code&gt;setProperty()&lt;/code&gt; methods. These methods provide a simple way for storing information into the low-level agents. However, it becomes quickly unmaintanable. The way for doing this should be the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean isTagged() {
    return &amp;quot;true&amp;quot;.equals(this.agent.getProperty(&amp;quot;TAGGED&amp;quot;));
}


public void setTagged(boolean tagged) {
    this.agent.setProperty(&amp;quot;TAGGED&amp;quot;, String.valueOf(tagged));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The initial value of &lt;code&gt;&amp;quot;TAGGED&amp;quot;&lt;/code&gt; should be introduced first in any agent of the environment.
&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/ITGP0JP.gif&#34;/&gt;&lt;/figure&gt;

And then, in the constructor of the behavior, we need to recover the metadata of provided from the environment and setting it into the agent&amp;rsquo;s attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public MyHelloHighLevelController(LowLevelAgent agent,
        Map&amp;lt;String, String&amp;gt; metadata, String resourcesFolder) {
    super(agent, metadata, resourcesFolder);
    this.agent.setHighLevelData(this);
    String taggedStr = metadata.get(&amp;quot;TAGGED&amp;quot;);
    if (taggedStr == null || !&amp;quot;true&amp;quot;.equals(metadata.get(&amp;quot;TAGGED&amp;quot;))) {
        this.setTagged(false);
    } else {
        this.setTagged(true);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check for seeing a tagged / untagged agent&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private MyHelloHighLevelController getNearestAgent(double range,
        boolean tagStatus) {
    /*
     * We set a high limit
     */
    double minDist = Float.MAX_VALUE;
    /*
     * Location of this agent
     */
    final Location agentLoc = this.agent.getLocation();
    /*
     * Nearest agent found
     */
    MyHelloHighLevelController nearest = null;
    for (LowLevelAgent otherAgent : this.agent.getAgentsInRange(range)) {
        /*
         * Retrieve the high-level data of the other agent. It should be of
         * the type of agent playing this game, MyHelloHighLevelController.
         */
        final Object highLevelData = otherAgent.getHighLevelData();
        if (highLevelData instanceof MyHelloHighLevelController) {
            MyHelloHighLevelController otherCtrl = (MyHelloHighLevelController) highLevelData;
            /*
             * Satisfies the search condition?
             */
            if (otherCtrl.isTagged() == tagStatus) {
                final Location otherLoc = otherAgent.getLocation();
                final double distance = agentLoc.distance2D(otherLoc);
                /*
                 * Store if nearest.
                 */
                if (distance &amp;lt; minDist) {
                    nearest = otherCtrl;
                    minDist=distance;
                }
            }
        }
    }
    return nearest;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check for detecting if the distance to the tagged agent is less than the maximum allowed: (&lt;em&gt;sees tagged agent&lt;/em&gt;, in the flowchart)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean seesTaggedAgent() {
        // true, because is tagged
        return getNearestAgent(search_range, true) != null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Check for the distance being less than 0.5 m (For the sake of completeness):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean isDistanceLessThan50cm(LowLevelAgent a1,LowLevelAgent a2) {
    return a1.getLocation().distance2D(a2.getLocation())&amp;lt;50;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;coding-the-flow:d7c5f655ae342b94fbf082b33a7e6e52&#34;&gt;Coding the flow&lt;/h3&gt;

&lt;p&gt;We have written the conditional checks of the flowchart. Let&amp;rsquo;s put the pieces together.
The &lt;code&gt;START&lt;/code&gt; section of the flowchart corresponds to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public void step() {
    // START
    if (this.isTagged()) {
        runAsTagged();
    } else {
        runAsNotTagged();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, going to the &lt;em&gt;not tagged&lt;/em&gt; branch,&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/nidqPY6.png&#34;/&gt;&lt;/figure&gt;


&lt;pre&gt;&lt;code&gt;private void runAsNotTagged() {
    // sees tagged agent?
    if (seesTaggedAgent()) {
        /*
         * Retrieve the polygon associated with the current room
         */
        KPolygon polygon = this.agent.getRoom().getPolygon();
        /*
         * If the agent&#39;s target is in the same room of the agent (and in
         * the same room as the &amp;quot;tagged&amp;quot; one), select a new target in a
         * different room.
         */
        while (this.randomTarget == null
                || polygon.contains(this.randomTarget.getXY())) {
            this.randomTarget = this.agent.getRandomRoom().getRandomLoc();
        }
    }
    this.moveRandomly();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new part here is the &lt;code&gt;getPolygon()&lt;/code&gt; method. In MASSIS, every simulation object has a polygonal representation. Here, we take advantage of that possibility to detect if a point is contained in a the room&amp;rsquo;s shape.&lt;/p&gt;

&lt;p&gt;For the  &lt;em&gt;tagged&lt;/em&gt; branch,&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/AyOQSGJ.png&#34;/&gt;&lt;/figure&gt;


&lt;p&gt;This is a little bit more complex than the other branch.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First, we need to check if there is any &lt;em&gt;not tagged&lt;/em&gt; agent in range. Remember that the &lt;code&gt;false&lt;/code&gt; parameter was because we want to obtain the agents that are not tagged.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyHelloHighLevelController nearest = getNearestAgent(search_range, false);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;After that, if there is any agent in range (that is, &lt;code&gt;nearest!=null&lt;/code&gt;), we check the distance to it&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If the distance &amp;lt; 0.5 meters (50 cm),&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The agent &lt;em&gt;tags&lt;/em&gt; it&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The agent &lt;em&gt;untags&lt;/em&gt; itself&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;final Location nearestLoc = nearest.agent.getLocation();
// Yes, and is the closest one.
// if distance &amp;lt; 0.5 m, (50 cm), tag it
final double distance = agentLoc.distance2D(nearestLoc);
if (distance &amp;lt; tag_max_distance) {
    // tag it
    nearest.setTagged(true);
    // un-tag itself
    this.setTagged(false);
    // end
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If not, the tagged agent just chase its nearest target.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.agent.approachTo(nearestLoc, new ApproachCallback() {


    @Override
    public void onTargetReached(LowLevelAgent agent) {
        // Nothing this time. We are handling the logic
        // elsewhere.
    }


    @Override
    public void onSucess(LowLevelAgent agent) {}


    @Override
    public void onPathFinderError(
            PathFinderErrorReason reason) {
        // Error!
        Logger.getLogger(
                MyHelloHighLevelController.class.getName())
                .log(Level.SEVERE,
                        &amp;quot;Error when approaching to {0} Reason: {1}&amp;quot;,
                        new Object[] { nearestLoc, reason });
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If there wasn&amp;rsquo;t any agent in range, just move randomly&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;this.moveRandomly();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Putting all together,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private void runAsTagged() {
    final Location agentLoc = this.agent.getLocation();
    // Sees un-tagged agent?
    MyHelloHighLevelController nearest = getNearestAgent(search_range,
            false);
    if (nearest != null) {
        final Location nearestLoc = nearest.agent.getLocation();
        // Yes, and is the closest one.
        // if distance &amp;lt; 0.5 m, (50 cm), tag it
        final double distance = agentLoc.distance2D(nearestLoc);
        if (distance &amp;lt; tag_max_distance) {
            // tag it
            nearest.setTagged(true);
            // un-tag itself
            this.setTagged(false);
            // end
        } else {
            // chase him
            this.agent.approachTo(nearestLoc, new ApproachCallback() {

                @Override
                public void onTargetReached(LowLevelAgent agent) {
                    // Nothing this time. We are handling the logic
                    // elsewhere.
                }

                @Override
                public void onSucess(LowLevelAgent agent) {
                }

                @Override
                public void onPathFinderError(
                        PathFinderErrorReason reason) {
                    // Error!
                    Logger.getLogger(
                            MyHelloHighLevelController.class.getName())
                            .log(Level.SEVERE,
                                    &amp;quot;Error when approaching to {0} Reason: {1}&amp;quot;,
                                    new Object[] { nearestLoc, reason });
                }
            });
        }
    } else {
        // no target found:
        this.moveRandomly();
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;moveRandomly()&lt;/code&gt; method is an adaptation of the previous code that made the agent move to random targets.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private Location randomTarget = null;

private void moveRandomly() {
    if (this.randomTarget == null) {
        Location randomLocation = this.agent.getRandomRoom().getRandomLoc();
        this.randomTarget = randomLocation;
    }
    this.agent.approachTo(this.randomTarget, new ApproachCallback() {

        @Override
        public void onTargetReached(LowLevelAgent agent) {
            randomTarget = null;
        }

        @Override
        public void onSucess(LowLevelAgent agent) {
        }

        @Override
        public void onPathFinderError(PathFinderErrorReason reason) {
            // Error!
            Logger.getLogger(MyHelloHighLevelController.class.getName())
                    .log(Level.SEVERE,
                            &amp;quot;Error when finding path Reason: {0}&amp;quot;, reason);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything went ok, the result should be something like this:&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/Jva4HPG.gif&#34;/&gt;&lt;/figure&gt;


&lt;blockquote&gt;
&lt;p&gt;Note: The code for the complete behavior is &lt;a href=&#34;https://gist.github.com/rpax/b457fa14d2a9d14779ab&#34;&gt;in this gist&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The problem is&amp;hellip; &lt;strong&gt;&lt;em&gt;Who is the tagged one&lt;/em&gt; ? All the agents are identical!&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.massisframework.com/post/tutorials/extending-the-gui/&#34;&gt;Next Tutorial&lt;/a&gt; solves that problem, explaining how to develop visualization utilities.&lt;/p&gt;

&lt;p&gt;[tag&lt;em&gt;game]: &lt;a href=&#34;https://en.wikipedia.org/wiki/Tag&#34;&gt;https://en.wikipedia.org/wiki/Tag&lt;/a&gt;&lt;/em&gt;(game)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating a MASSIS Application. Part 6: Extending the GUI</title>
      <link>http://www.massisframework.com/post/tutorials/extending-the-gui/</link>
      <pubDate>Fri, 06 Nov 2015 13:19:52 +0100</pubDate>
      
      <guid>http://www.massisframework.com/post/tutorials/extending-the-gui/</guid>
      <description>

&lt;p&gt;This is the continuation of the &lt;a href=&#34;http://www.massisframework.com/post/tutorials/perception/&#34;&gt;Tutorial 5&lt;/a&gt;.
The problem we faced in the previous tutorial was that we couldn&amp;rsquo;t visualize the &lt;em&gt;state&lt;/em&gt; of the agents (if they were tagged or not).&lt;/p&gt;

&lt;p&gt;In a &lt;a href=&#34;http://www.massisframework.com/post/tutorials/defining-a-simple-behavior/&#34;&gt;previous tutorial&lt;/a&gt; was introduced the different types of visualization that MASSIS has. In this tutorial we will go deeper into this topic, and we will learn how to extend the default MASSIS layer system.&lt;/p&gt;

&lt;h1 id=&#34;massis-visualization-displays-revisited:e3159b7eb98b2df94b444a2728f839f9&#34;&gt;MASSIS visualization displays revisited&lt;/h1&gt;

&lt;p&gt;All the changes made in the environment during the simulation are reflected in real time by 3D  and 2D displays.
Although 3D display is more realistic, the 2D view is useful for analysis and debugging. Also, the 2D layered visualization system allows the creation of user-defined layers.&lt;/p&gt;

&lt;h1 id=&#34;3d-display:e3159b7eb98b2df94b444a2728f839f9&#34;&gt;3D display&lt;/h1&gt;

&lt;p&gt;This type of visualization is an adaptation of the 3D view of SweetHome3D. Although it lacks of flexibility, gives a better view of what&amp;rsquo;s happening in the simulation.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/e0P2XJ5.gif&#34;/&gt;&lt;/figure&gt;


&lt;h1 id=&#34;sweethome3d-2d-display:e3159b7eb98b2df94b444a2728f839f9&#34;&gt;SweetHome3D 2D display&lt;/h1&gt;

&lt;p&gt;During the first development iteration, this type of display was the one that was used, but it is not maintained anymore. It had thread safety problems, and does not always work. Its usage it is discoraged. It has been left because&amp;hellip;why not?. Maybe it is useful in the future.&lt;/p&gt;

&lt;h1 id=&#34;massis-2d-display:e3159b7eb98b2df94b444a2728f839f9&#34;&gt;MASSIS 2D display&lt;/h1&gt;

&lt;p&gt;This is the most powerful visualization utility of MASSIS. It is not intended for realism, (it is plain 2D), but it provides a great flexibility, and extensibility. It is based on layers, which can be drawn one on top of each other, and multiple things can be viewed at the same time. Also, they can be enabled and disabled.
It is the recommended visualization for developers and people interested in analizing concrete issues.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/Q6mbTo8.gif&#34;/&gt;&lt;/figure&gt;


&lt;h2 id=&#34;tabs-levels:e3159b7eb98b2df94b444a2728f839f9&#34;&gt;Tabs &amp;amp; Levels&lt;/h2&gt;

&lt;p&gt;Each floor (level) of the simulation environment has its own tab, that makes the task of switching between floors faster.
This type of display allows zooming and panning, and each tab maintains its zoom state, so switching between interesting points (such as bottlenecks in different floors), does not imply a headache.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/DTBu6RA.gif&#34;/&gt;&lt;/figure&gt;


&lt;h2 id=&#34;default-layers:e3159b7eb98b2df94b444a2728f839f9&#34;&gt;Default Layers&lt;/h2&gt;

&lt;p&gt;MASSIS 2D display comes with several general-purpose layers, that might be useful most of the times, and also can serve as an example for creating new ones. They are as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rooms: Draws the rooms areas&lt;/li&gt;
&lt;li&gt;Rooms Labels: Draws the name of the rooms&lt;/li&gt;
&lt;li&gt;Vision Radio : Draws the vision radio of the agents&lt;/li&gt;
&lt;li&gt;Crowd density: Draws the crowd density represented as a heatmap&lt;/li&gt;
&lt;li&gt;Walls : Draws the walls of the building&lt;/li&gt;
&lt;li&gt;Connections : Draws the pathfinder visibility graph connections&lt;/li&gt;
&lt;li&gt;Doors : Draws the doors of the floor&lt;/li&gt;
&lt;li&gt;Paths : Draws the paths that the agents are following&lt;/li&gt;
&lt;li&gt;PathFinder : Draws the obstacles recognized by the pathfinder&lt;/li&gt;
&lt;li&gt;People : Draws the dynamic obstacles, as arrows&lt;/li&gt;
&lt;li&gt;Body radios : Draws the proximity radio of the dynamic elements of the environment&lt;/li&gt;
&lt;li&gt;Visible agent lines: Shows a which nodes are the agents and the edges are the visible connection between them&lt;/li&gt;
&lt;li&gt;QuadTree : Shows the bottom-up propagation quadtree representation&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;creating-a-custom-layer:e3159b7eb98b2df94b444a2728f839f9&#34;&gt;Creating a custom layer&lt;/h1&gt;

&lt;h2 id=&#34;how-layers-are-structured:e3159b7eb98b2df94b444a2728f839f9&#34;&gt;How layers are structured&lt;/h2&gt;

&lt;p&gt;After this introduction, the obvious question is: &lt;em&gt;How do I implement my own custom layer?&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The layer system in massis is based on the &lt;a href=&#34;https://github.com/rpax/MASSIS/tree/master/massisframework/massisframework-utils/massis-gui&#34;&gt;massis gui utility package&lt;/a&gt;.
The building visualization system is composed by a set of layers of &lt;code&gt;DrawableFloor&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;One of the most basic layer is the Room layer. It only fills the polygons representing the rooms:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Draws each room of the floor
 *
 * @author rpax
 *
 */
public class RoomsLayer extends DrawableLayer&amp;lt;DrawableFloor&amp;gt; {

    public RoomsLayer(boolean enabled)
    {
        super(enabled);

    }

    @Override
    public void draw(DrawableFloor dfloor, Graphics2D g)
    {
        final Floor f = dfloor.getFloor();
        for (SimRoom r : f.getRooms())
        {
            g.setColor(Color.gray);
            g.fill(r.getPolygon());
        }

    }

    @Override
    public String getName()
    {
        return &amp;quot;Rooms&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every time a repaint is needed, the visualization systems makes a call to &lt;code&gt;draw(DrawableFloor dfloor, Graphics2D g)&lt;/code&gt;. That is the place where the drawing should occur. The scaling, offseting and panning issues are already resolved,
so in this method the only things that should be done are the calls to the &lt;code&gt;Graphics2D&lt;/code&gt; methods.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tip: you can also take advantage of the utility class &lt;a href=&#34;https://github.com/rpax/MASSIS/blob/master/massisframework/massis/massis-core/src/main/java/com/massisframework/massis/displays/floormap/layers/FloorMapLayersUtils.java&#34;&gt;&lt;code&gt;FloorMapLayersUtils&lt;/code&gt;&lt;/a&gt;, which contains several methods that make less tedious the drawing common tasks. (Casting to ints, drawing points, lines, polygons, etc.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Another interesting layer is the &amp;ldquo;People&amp;rdquo; layer. This layer shows the triangles representing the dynamic elements of the simulation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static Color DEFAULT_PERSON_FILL_COLOR = Color.WHITE;
private static Color DEFAULT_PERSON_DRAW_COLOR = Color.BLUE;

@Override
public void draw(DrawableFloor dfloor, Graphics2D g)
{
    final Floor f = dfloor.getFloor();
    g.setColor(Color.red);

    for (DefaultAgent p : f.getAgents())
    {
        if (!p.isDynamic())
        {
            g.setColor(new Color(165, 42, 42));
            g.fill(p.getPolygon());
        }
    }
    for (DefaultAgent p : f.getAgents())
    {
        if (p.isDynamic())
        {
            KPolygon poly = KPolygon.createRegularPolygon(3, p.getPolygon()
                    .getRadius());
            poly.scale(1, 0.6);

            poly.rotate(p.getAngle());
            poly.translateTo(p.getX(), p.getY());

            g.setColor(DEFAULT_PERSON_FILL_COLOR);

            g.fill(poly);
            g.setColor(DEFAULT_PERSON_DRAW_COLOR);
            g.draw(poly);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As yu can observe, the idea of this &amp;ldquo;layered&amp;rdquo; way for drawing is modularity. A layer is conceived for a very specific task, and should be small. If it starts to become bigger, think about splitting it into two.&lt;/p&gt;

&lt;h2 id=&#34;the-game-layer:e3159b7eb98b2df94b444a2728f839f9&#34;&gt;The game layer&lt;/h2&gt;

&lt;p&gt;We want to create a layer that shows the difference between the agents status. For example, the tagged agent should be red. Taking &lt;code&gt;PeopleLayer&lt;/code&gt; as an example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private static Color DEFAULT_PERSON_FILL_COLOR = Color.WHITE;
private static Color DEFAULT_PERSON_DRAW_COLOR = Color.BLUE;

@Override
public void draw(DrawableFloor dfloor, Graphics2D g)
{
    final Floor f = dfloor.getFloor();
    g.setColor(Color.red);

    for (DefaultAgent p : f.getAgents())
    {
        if (!p.isDynamic())
        {
            g.setColor(new Color(165, 42, 42));
            g.fill(p.getPolygon());
        }
    }
    for (DefaultAgent p : f.getAgents())
    {
        if (p.isDynamic())
        {
            KPolygon poly = KPolygon.createRegularPolygon(3, p.getPolygon()
                    .getRadius());
            poly.scale(1, 0.6);

            poly.rotate(p.getAngle());
            poly.translateTo(p.getX(), p.getY());

            g.setColor(DEFAULT_PERSON_FILL_COLOR);

            g.fill(poly);
            g.setColor(DEFAULT_PERSON_DRAW_COLOR);
            g.draw(poly);
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Creating a MASSIS Application. Part 1: Downloading a basic archetype</title>
      <link>http://www.massisframework.com/post/tutorials/sample-massis-application/</link>
      <pubDate>Thu, 05 Nov 2015 13:19:52 +0100</pubDate>
      
      <guid>http://www.massisframework.com/post/tutorials/sample-massis-application/</guid>
      <description>

&lt;p&gt;This tutorial covers the basic topics about creating a simple agent behavior for MASSIS. It is assumed that the section about &lt;a href=&#34;http://www.massisframework.com/page/getting-started/&#34;&gt;downloading&lt;/a&gt; has been read.&lt;/p&gt;

&lt;p&gt;Although an experienced programmer can do all of this steps without any kind of IDE, for illustrating purposes, the &lt;a href=&#34;http://www.eclipse.org/downloads/&#34;&gt;Eclipse platform&lt;/a&gt; will be used here. The recommended version is the &lt;em&gt;Eclipse IDE for Java Developers&lt;/em&gt;.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/6574ISB.png&#34;/&gt;&lt;/figure&gt;


&lt;h2 id=&#34;creating-a-maven-project-based-on-a-massis-archetype:e06228b655e61d4d03702e703f2b69d5&#34;&gt;Creating a maven project based on a massis archetype&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Right click on the projects sidebar, and select &amp;ldquo;New Project&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/jHjluiC.png&#34;/&gt;&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;In the project type window, select new Maven Project and press &lt;em&gt;Next&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/nekxikS.png&#34;/&gt;&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;Ensure that the checkbox &lt;em&gt;Skip Archetype Selection&lt;/em&gt; is &lt;strong&gt;unchecked&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/uNrk3nQ.png&#34;/&gt;&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;Now, we need to add the massis archetype catalog. This can be done through &lt;em&gt;Configure&amp;hellip; -&amp;gt; Add Remote Catalog&lt;/em&gt;, and selecting the massis archetype catalog,which is located at &lt;a href=&#34;http://mvn.massisframework.com/nexus/content/groups/public/archetype-catalog.xml&#34;&gt;http://mvn.massisframework.com/nexus/content/groups/public/archetype-catalog.xml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/NwtY4Wk.png&#34;/&gt;&lt;/figure&gt;


&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/0KDUOcB.png&#34;/&gt;&lt;/figure&gt;


&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/hRWww0Z.png&#34;/&gt;&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;Remember to check the option &lt;em&gt;Include snapshot archetypes&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/h4hT8Jr.png&#34;/&gt;&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;The next window asks for the information about our groupId and artifactId. In this example, the groupId will be &lt;code&gt;tutorialfollower&lt;/code&gt; and the artifactId &lt;code&gt;myfirstmassisproject&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/KbjsvNR.png&#34;/&gt;&lt;/figure&gt;


&lt;p&gt;After pressing &lt;em&gt;Finish&lt;/em&gt;, Eclipse (maven) will start downloading the required dependencies for this project. Depending on your internet connection, this may take a while. The progress can be seen on the &lt;em&gt;Progress&lt;/em&gt; tab. (Or clicking in the bottom right corner of the window).&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/YjNf5ai.png&#34;/&gt;&lt;/figure&gt;


&lt;p&gt;If you want to see the output of the maven console, this can be done in the &lt;em&gt;Console tab -&amp;gt; Maven Console&lt;/em&gt;&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/Bojyyev.png&#34;/&gt;&lt;/figure&gt;


&lt;p&gt;The output should be something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;12/11/15, 6:11:42 PM GMT+1: [INFO] Downloading https://repo1.maven.org/maven2/org/jogamp/jogl/jogl-all/2.3.2/jogl-all-2.3.2-natives-macosx-universal.jar
12/11/15, 6:11:43 PM GMT+1: [INFO] Downloaded https://repo1.maven.org/maven2/org/jogamp/jogl/jogl-all/2.3.2/jogl-all-2.3.2-natives-macosx-universal.jar
12/11/15, 6:11:43 PM GMT+1: [INFO] Downloading https://repo1.maven.org/maven2/org/jogamp/jogl/jogl-all/2.3.2/jogl-all-2.3.2-natives-solaris-amd64.jar
12/11/15, 6:11:44 PM GMT+1: [INFO] Downloaded https://repo1.maven.org/maven2/org/jogamp/jogl/jogl-all/2.3.2/jogl-all-2.3.2-natives-solaris-amd64.jar
12/11/15, 6:11:44 PM GMT+1: [INFO] Downloading https://repo1.maven.org/maven2/org/jogamp/jogl/jogl-all/2.3.2/jogl-all-2.3.2-natives-solaris-i586.jar
12/11/15, 6:11:44 PM GMT+1: [INFO] Downloaded https://repo1.maven.org/maven2/org/jogamp/jogl/jogl-all/2.3.2/jogl-all-2.3.2-natives-solaris-i586.jar
12/11/15, 6:11:44 PM GMT+1: [INFO] Downloading https://repo1.maven.org/maven2/org/jogamp/jogl/jogl-all/2.3.2/jogl-all-2.3.2-natives-windows-amd64.jar
12/11/15, 6:11:45 PM GMT+1: [INFO] Downloaded https://repo1.maven.org/maven2/org/jogamp/jogl/jogl-all/2.3.2/jogl-all-2.3.2-natives-windows-amd64.jar
12/11/15, 6:11:45 PM GMT+1: [INFO] Downloading https://repo1.maven.org/maven2/org/jogamp/jogl/jogl-all/2.3.2/jogl-all-2.3.2-natives-windows-i586.jar
12/11/15, 6:11:45 PM GMT+1: [INFO] Downloaded https://repo1.maven.org/maven2/org/jogamp/jogl/jogl-all/2.3.2/jogl-all-2.3.2-natives-windows-i586.jar
12/11/15, 6:09:57 PM GMT+1: [INFO] Downloaded https://repo1.maven.org/maven2/xalan/xalan/2.6.0/xalan-2.6.0.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once all dependencies are downloaded, the project should contain three files:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EnvironmentEditor.java&lt;/code&gt; : Contains the necessary code for launching the environment editor.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SimulationWithUILauncher.java&lt;/code&gt; : This class is responsible for launching the simulator&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MyHelloHighLevelController&lt;/code&gt; : A behavior definion sample.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/37HqUP4.png&#34;/&gt;&lt;/figure&gt;
&lt;/p&gt;

&lt;h1 id=&#34;what-to-do-next:e06228b655e61d4d03702e703f2b69d5&#34;&gt;What to do next?&lt;/h1&gt;

&lt;p&gt;The tutorial continues on &lt;a href=&#34;http://www.massisframework.com/post/tutorials/customizing-the-archetype/&#34;&gt;Creating a MASSIS Application. Part 2: Customizing the archetype&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Authors</title>
      <link>http://www.massisframework.com/page/authors/</link>
      <pubDate>Thu, 05 Nov 2015 09:56:34 +0100</pubDate>
      
      <guid>http://www.massisframework.com/page/authors/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Downloading MASSIS</title>
      <link>http://www.massisframework.com/page/getting-started/</link>
      <pubDate>Thu, 05 Nov 2015 09:56:34 +0100</pubDate>
      
      <guid>http://www.massisframework.com/page/getting-started/</guid>
      <description>

&lt;p&gt;The following requirements are needed for running MASSIS:&lt;/p&gt;

&lt;h2 id=&#34;software:b6885e1f85551f51a4707c402f8200a3&#34;&gt;Software&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java 1.7 or later&lt;/strong&gt; (Can be downloaded from the &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/index.html&#34;&gt;oracle web page&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: Remember to add the &lt;code&gt;JAVA_HOME&lt;/code&gt; environment variable in your OS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Maven 3.1.1+&lt;/strong&gt; (Can be downloaded from the &lt;a href=&#34;https://maven.apache.org/download.cgi&#34;&gt;Maven download site&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: Remember to add the &lt;code&gt;M2_HOME&lt;/code&gt; environment variable in your OS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ant:&lt;/strong&gt; (Can be downloaded from the &lt;a href=&#34;https://ant.apache.org/bindownload.cgi&#34;&gt;Apache Ant download page&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: Remember to add the &lt;code&gt;ANT_HOME&lt;/code&gt; environment variable in your OS.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;ide:b6885e1f85551f51a4707c402f8200a3&#34;&gt;IDE&lt;/h2&gt;

&lt;p&gt;Although MASSIS can be used without any kind of IDE, it is recommended to do so. Two good IDE&amp;rsquo;s are &lt;a href=&#34;https://eclipse.org/downloads/&#34;&gt;Eclipse&lt;/a&gt; and &lt;a href=&#34;https://netbeans.org/downloads/&#34;&gt;Netbeans&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;using-massis:b6885e1f85551f51a4707c402f8200a3&#34;&gt;Using MASSIS&lt;/h2&gt;

&lt;p&gt;There are two ways for using MASSIS. Downloading the source code from Github, or developing custom applications, and referencing MASSIS&amp;rsquo; maven artifacts.&lt;/p&gt;

&lt;h3 id=&#34;option-1-downloading-the-source-code:b6885e1f85551f51a4707c402f8200a3&#34;&gt;Option 1: Downloading the source code&lt;/h3&gt;

&lt;p&gt;This is the recommended option for changing core features of MASSIS. The necessary MASSIS&amp;rsquo; modules are hosted at Github, in the following repositories:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rpax/MASSIS&#34;&gt;Main MASSIS Repository&lt;/a&gt; : Contains the basic MASSIS&amp;rsquo; features.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rpax/straightedge&#34;&gt;StraightEdge Repository&lt;/a&gt;: Contains the same source code of the original &lt;a href=&#34;https://code.google.com/p/straightedge/&#34;&gt;StraightEdge&amp;rsquo;s Google Code page&lt;/a&gt;, but it has been &lt;em&gt;mavenized&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rpax/sweethome3d&#34;&gt;SweetHome3D repository&lt;/a&gt;: Contains the source code of the original &lt;a href=&#34;http://www.sweethome3d.com/download.jsp&#34;&gt;SweetHome3D&lt;/a&gt; page, but its external libraries are referenced as maven dependencies.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rpax/massis-sh3d-plugins&#34;&gt;SweetHome3D plugins repository&lt;/a&gt;. Contains extensions for the environment design with SweetHome3D for MASSIS.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;option-2-using-massis-artifacts-as-maven-dependency-of-another-project:b6885e1f85551f51a4707c402f8200a3&#34;&gt;Option 2: Using MASSIS&amp;rsquo; artifacts as maven dependency of another project&lt;/h3&gt;

&lt;p&gt;This is the preferred option if the objective of your project is developing an application using MASSIS&amp;rsquo; features, without changing MASSIS&amp;rsquo; source code.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.massisframework.com/categories/tutorials/&#34;&gt;tutorials section&lt;/a&gt; contains examples about creating an application based on MASSIS&amp;rsquo; framework.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What is MASSIS?</title>
      <link>http://www.massisframework.com/about/</link>
      <pubDate>Sun, 01 Nov 2015 13:23:29 +0100</pubDate>
      
      <guid>http://www.massisframework.com/about/</guid>
      <description>&lt;p&gt;MASSIS is a simulation framework for scenarios in indoor environments, allowing to design spaces, and specifying the behavior of the elements and people in them. These behaviors specifications may vary substantially: From a simple presence detector to human behavior. It is capable of supporting thousands of agents, each one with an specific behavior. The behavior specification is done outside the simulation platform, and multiple behavior models can be integrated.&lt;/p&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/1AnvPlq.png&#34;/&gt;&lt;/figure&gt;


&lt;p&gt;The simulation progress can be visualized in 3D, from different perspectives, or in 2D. The 2D visualization library is based on layers (the elements of each layer are drawn on top of the previous layer), making easier the development of a new type of visualization for specific purposes. Also, it allows to save the simulation changes, recording each agent state in every step of the simulation. These changes are saved in an open and independent format (JSON), allowing the analysis of the results from any other platform and language.&lt;/p&gt;

&lt;p&gt;&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/PuXmC7F.png&#34;/&gt;&lt;/figure&gt;

&lt;figure class=&#34;img-responsive center-block&#34;&gt;&lt;img src=&#34;http://i.imgur.com/Uw6JFi3.png&#34;/&gt;&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Both MASSIS and its components are open source, allowing the extension of its functionality by third parties.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>